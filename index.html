<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  小马同学的碎碎念
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="小马同学的碎碎念" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 小马同学的碎碎念</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15794268006874.html">
                
                  <h1>iOS 技术文档计划</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ol>
<li>自动释放池</li>
<li>多线程</li>
<li>锁</li>
<li>数据坤</li>
<li>冷启动优化</li>
<li>APP 健壮性设计</li>
<li>iOS 性能优化</li>
<li>网络相关</li>
<li>内存管理</li>
<li>iOS 架构设计</li>
<li>设计模式</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/01/19</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15791552193020.html">
                
                  <h1>RunLoop 详解</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>RunLoop 概念</li>
<li>RunLoop与线程的关系<br/>
## RunLoop 概念<br/>
一般来讲一个线程一次只能执行一个任务,执行完成后线程就会推出了,很明显,现在的 APP 都是不可能这种模式的,否则 APP 打开之后就死掉了,也就没有任何作用了.<br/>
现在的这种模式其实是一种循环模式,保持一个线程始终存在,然后再处理各种操作(功能)等.<br/>
现在 APP 的实现机制其实是需要线程能随时处理事件,但是并不退出,通常的代码逻辑是这样的:(伪代码)
<img src="media/15791552193020/15794166325797.jpg" alt="" style="width:772px;"/>
从代码可以看出是一种循环机制.<br/>
这种模式通常被称为 EventLoop.iOS/OSX里的 runloop 就是这种模式.<br/>
这种模式的关键点:
<ul>
<li>如何管理事件/消息</li>
<li>如何让线程在没有消息处理的时候休眠,避免占用资源</li>
<li>在有消息需要处理的时候立刻被唤醒(否则就是卡顿了)</li>
</ul></li>
</ul>

<p>所以 runloop 实际上就是一个对象,这个对象管理了需要其处理的事件和消息.并且提供了一个入口函数来执行上面的 EventLoop 逻辑.<br/>
线程执行了这个函数之后,就会一直处于这个函数内部&quot;接受消息-&gt;等待-&gt;处理&quot;的循环中,知道这个循环结束,函数返回.<br/>
OSX/iOS 中提供了两个这样对象:<strong>NSRunLoop,CFRunLoopRef</strong> .</p>

<ul>
<li>CFRunLoopRef 是在 CoreFoundation 框架内的,提供的纯 C 函数的 API,所有这些 API 都是线程安全的.</li>
<li>NSRunLoop 是基于 CFRunLoopRef 的封装,提供了面向对象的 API,但是这些 API 不是线程安全的</li>
</ul>

<h2 id="toc_0">RunLoop 与线程的关系</h2>

<p>先给结论:<br/>
   1. RunLoop 和线程是一一对应的.<br/>
   2. RunLoop 和线程的对应关系保存在一个全局的字典里<br/>
   3. 线程刚创建的时候是没有 RunLoop 的,如果不主动获取就一直不会有!<br/>
   4. RunLoop 的创建是发生在第一次获取时.<br/>
   5. RunLoop 的销毁是发生在线程结束时<br/>
   6. 你只能在一个线程内部获取其 RunLoop(主线程除外)<br/>
   7. 苹果并不允许主动创建 RunLoop,只提供了两个获取的函数:CFRunLoopGetMain(),CFRunLoopGetCurrent().<br/>
<img src="media/15791552193020/15794176750269.jpg" alt="" style="width:916px;"/></p>

<p>在 CoreFoundation 中关于 RunLoop 有 5 个类:</p>

<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef<br/>
其中的 CFRunLoopModeRef 并没有对外暴露,只是通过 CFRunLoopRef 的接口对外进行了封装
<img src="media/15791552193020/15794179265453.jpg" alt="" style="width:724px;"/>
一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。
<strong>如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</strong></li>
</ul>

<p><strong>CFRunLoopSourceRef</strong> 是事件产生的地方。Source有两个版本：Source0 和 Source1。</p>

<ol>
<li>Source0 只包含了一个回调(函数指针)</li>
<li><p>Source1 包含了一个回调(函数指针)和一个 mach_port</p>
<p>Source0 并不能主动触发事件,使用的时候需要先调用CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理,然后手动调用CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。<br/>
Source1 能主动唤醒 RunLoop 的线程.通常用于内核和其他线程相互发送消息</p></li>
</ol>

<p><strong>CFRunLoopTimerRef</strong> 是基于时间的触发器,它和 NSTimer 是toll-free bridged <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup> 的,可以混用.其包含一个时间长度和一个回调(函数指针).当其加入 RunLoop 中时,RunLoop 会注册对应的时间点,当时间点到了,RunLoop 会被唤醒以执行那个回调.</p>

<p><strong>CFRunLoopObserverRef</strong> 是观察者,每个 Observer 都包含了一个回调(函数指针),当 RunLoop 的状态发生变化时,观察者就能通过回调接受到这个变化.可以观察的时间点:<br/>
<img src="media/15791552193020/15794192089256.jpg" alt="" style="width:995px;"/></p>

<p>上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>

<h2 id="toc_1">RunLoop 的 Mode</h2>

<p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：<br/>
<img src="media/15791552193020/15794203021817.jpg" alt="" style="width:1225px;"/><br/>
这里有一个概念叫&quot;CommonModes&quot;:<br/>
    一个 Mode 可以将自己标记为&quot;common&quot;属性(通过将其 ModeName 添加到 RunLoop 的&quot;commonModes&quot;中),每当 Runloop 的内容发生变化时,RunLoop 会自动将_commonModeItems 里的 Source/Obsever/Timer 同步到具有 Common 标记的所有 Mode 里<br/><br/>
<img src="media/15791552193020/15794205749856.jpg" alt="" style="width:1527px;"/><br/>
<img src="media/15791552193020/15794206571347.jpg" alt="" style="width:1537px;"/></p>

<h2 id="toc_2">RunLoop 的内部逻辑</h2>

<p>根据苹果在文档里的说明，RunLoop 内部的逻辑大致如下:<br/>
<img src="media/15791552193020/15794207296297.jpg" alt="" style="width:1118px;"/></p>

<p>内部代码整理:<br/>
<img src="media/15791552193020/FireShot%20Capture%20023%20-%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RunLoop%20-%20Garan%20no%20dou%20-%20blog.ibireme.com.png" alt="FireShot Capture 023 - 深入理解RunLoop - Garan no dou - blog.ibireme.co"/><br/>
可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>

<h2 id="toc_3">苹果用 Runloop 实现的功能</h2>

<ol>
<li>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li>
<li>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li>
<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。<br/>
4: GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。<br/>
5: kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</li>
</ol>

<h3 id="toc_4">AutoreleasePool</h3>

<p>App 启动之后,苹果在主线程 RunLoop 里注册了两个 Observer,这两个观察者的回调都是_wrapRunLoopWithAutoreleasePoolHandler().</p>

<ul>
<li>第一个 Observer 监视的事件是 Entry(即将进入 Loop)其回调回调用_objc_autoreleasePoolPush()创建自动释放池,优先级最高,保证创建自动释放池在所有回调之前</li>
<li>第二个 Observer 监视了两个事件:
<ol>
<li>BeforeWaiting(准备进入休眠)时调用_objc_autoreleasePoolPop()和_objc_autoreleasePoolPush()释放旧的池并创建新的自动释放池;</li>
<li>Exit(退出Loop)时调用_objc_autoreleasePoolPop()释放自动释放池,这个 Observer 的优先级最低,保证释放自动释放池发生在所有回调之后</li>
</ol></li>
</ul>

<h3 id="toc_5">事件响应</h3>

<p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>

<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>

<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>

<p>参考:<br/>
<a href="https://blog.ibireme.com/2015/05/18/runloop/">https://blog.ibireme.com/2015/05/18/runloop/</a></p>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>Toll-free bridging,简称为TFB，是一种允许某些ObjC类与其对应的CoreFoundation类之间可以互换使用的机制。比如 NSString与CFString是桥接(bridged)的, 这意味着可以将任意NSString当做CFString使用，也可以将任意的CFString当做NSString使用&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/01/16</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15788827057157.html">
                
                  <h1>Runtime</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><img src="media/15788827057157/15788999942773.jpg" alt="" style="width:939px;"/><br/>
Runtime 的特性主要是消息（方法）传递，如果消息（方法）在对象中找不到，就会进行消息转发。</p>

<h2 id="toc_0">Runtime 介绍</h2>

<blockquote>
<p>Objective-C 拓展了 C语言，并且加入了面向对象特性和 SmallTalk 式的消息传递机制，而这个拓展的核心就是用 C 和编译语言写的Runtime库。Runtime是面向对象的基础。</p>
</blockquote>

<p><img src="media/15788827057157/15789003887697.jpg" alt="" style="width:684px;"/></p>

<h2 id="toc_1">Runtime 消息传递</h2>

<p>一个对象的方法[obj foo]，编译器转成消息转发：<strong>objc_msgSend(obj, foo)</strong><br/>
Runtime 执行的流程如下：</p>

<ul>
<li>首先通过 obj 的 isa 指针， 找到他的 Class</li>
<li>在 class 的 methodlist（方法列表） 列表中找方法： foo</li>
<li>如果 class 中没有找到 foo，就向上去父类的方法列表中继续查找；</li>
<li>如果找到了就执行，去实现 IMP。</li>
</ul>

<p><img src="media/15788827057157/15789011491768.jpg" alt="" style="width:687px;"/><br/>
<img src="media/15788827057157/15789013576022.jpg" alt="" style="width:664px;"/></p>

<ol>
<li>系统首先找到消息的接收对象,然后通过对象的 isa 找到他的类 class.</li>
<li>然后在他的类中查找 method_list,是否有 selector 方法</li>
<li>没有找到则继续查找父类的 method_list.</li>
<li>找到对应的 method,执行他的 IMP</li>
<li>转发 IMP 的 return 值.</li>
</ol>

<p>下面讲一下消息传递中用到的概念:</p>

<ul>
<li>类对象(objc_class)</li>
<li>实例对象(objc_object)</li>
<li>元类(Meta Class)</li>
<li>Method(objc_method)</li>
<li>SEL(objc_selector)</li>
<li>IMP</li>
<li>类缓存(objc_cache)</li>
<li>Category(objc_category)</li>
</ul>

<h3 id="toc_2">类对象(objc_class)</h3>

<p>在 OC 中类是有 Class 类型表示的,它实际上是一个指向 objc_class 的结构体指针<br/>
<img src="media/15788827057157/15789018290104.jpg" alt="" style="width:295px;"/><br/>
<img src="media/15788827057157/15789018799631.jpg" alt="" style="width:960px;"/><br/>
struct objc_class结构体定义了很多变量，通过命名不难发现，<br/>
结构体里保存了指向父类的指针、类的名字、版本、实例大小、实例变量列表、方法列表、缓存、遵守的协议列表等，<br/>
一个类包含的信息也不就正是这些吗？没错，类对象就是一个结构体struct objc_class，这个结构体存放的数据称为元数据(metadata)，<br/>
该结构体的第一个成员变量也是isa指针，这就说明了Class本身其实也是一个对象，因此我们称之为类对象，类对象在编译期产生用于创建实例对象，是单例。</p>

<h3 id="toc_3">实例(objc_object)</h3>

<p><img src="media/15788827057157/15789019974820.jpg" alt="" style="width:420px;"/></p>

<p>类对象中的元数据存储的都是如何创建一个实例相关的信息,那么类对象和类方法应该从哪里创建呢? 就是 isa 指针指向的结构体创建,类对象的 isa 指针指向的我们称为元类,元类中保存了创建类对象及类方法所需的所有信息,所以经典的那张图又来了:<br/>
<img src="media/15788827057157/15789021597096.jpg" alt="" style="width:934px;"/></p>

<h3 id="toc_4">元类(Meta Class)</h3>

<p>通过上图我们可以发现整个体系构成了一个自闭环, <strong>struct objc_object</strong> 的结构体实例, 它的 isa 指向类对象,类对象的 isa 指向元类,super_class 指针指向父类的类对象,而元类的 super_class 的指针指向了父类的元类,那元类的指针又指向了自己.<br/>
元类是一个类对象的类,在上面我们提到所有的类自身也是一个对象,我们可以像这个对象发送消息(调用方法),为了调用类方法,这个类的 isa 指针必须指向一个包含这些类方法的一个 objc_class 结构体,这就引出了元类(meta-class)的概念.<br/>
元类中保存了创建类对象以及类方法所需的所有信息。 任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而<strong>基类的meta-class的isa指针是指向它自己</strong>。</p>

<p><img src="media/15788827057157/15789044962794.jpg" alt="" style="width:881px;"/></p>

<ul>
<li>SEL method_name    方法名</li>
<li>char *method_types 方法类型</li>
<li>IMP method_imp     方法实现</li>
</ul>

<p><img src="media/15788827057157/15789046998441.jpg" alt="" style="width:728px;"/></p>

<p>objc_msgSend 函数第二个参数类型为 SEL.它是 selector 在 OC 中的表示类型(Swift 中是 Selector 类).selector 是方法选择器,可以理解为区分方法的 ID,而这个 ID 的数据结构是 SEL.<br/>
<img src="media/15788827057157/15789049888500.jpg" alt="" style="width:972px;"/></p>

<p><img src="media/15788827057157/15789050086371.jpg" alt="" style="width:988px;"/></p>

<p><img src="media/15788827057157/15789060707679.jpg" alt="" style="width:978px;"/></p>

<p><img src="media/15788827057157/15789062512658.jpg" alt="" style="width:547px;"/></p>

<ul>
<li>name:是指 class_name 而不是 category_name。</li>
<li>cls:要扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对 应到对应的类对象。</li>
<li>instanceMethods：category中所有给类添加的实例方法的列表。</li>
<li>classMethods：category中所有添加的类方法的列表。</li>
<li>protocols：category实现的所有协议的列表。</li>
<li>instanceProperties：表示Category里所有的properties，这就是我们可以通过objc_setAssociatedObject和objc_getAssociatedObject增加实例变量的原因，不过这个和一般的实例变量是不一样的。</li>
</ul>

<p><img src="media/15788827057157/15789063762697.jpg" alt="" style="width:983px;"/></p>

<h2 id="toc_5">Runtime 消息转发</h2>

<p>消息转发的最后三次机会</p>

<ul>
<li>动态方法解析</li>
<li>备用接受者</li>
<li>完整消息转发</li>
</ul>

<p><img src="media/15788827057157/15789064378501.jpg" alt="" style="width:974px;"/></p>

<h3 id="toc_6">动态方法解析</h3>

<p><img src="media/15788827057157/15789066286973.jpg" alt="" style="width:964px;"/></p>

<p>可以看到虽然没有实现foo:这个函数，但是我们通过class_addMethod动态添加fooMethod函数，并执行fooMethod这个函数的IMP。从打印结果看，成功实现了。<br/>
如果resolve方法返回 NO ，运行时就会移到下一步：<strong>forwardingTargetForSelector</strong>。</p>

<h3 id="toc_7">备用接受者</h3>

<p>如果目标对象实现了<strong>-forwardingTargetForSelector:</strong>，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。</p>

<p>实现一个备用接收者的例子如下：</p>

<p><img src="media/15788827057157/15789068795712.jpg" alt="" style="width:667px;"/><br/>
可以看到我们通过forwardingTargetForSelector把当前ViewController的方法转发给了Person去执行了。打印结果也证明我们成功实现了转发。</p>

<h3 id="toc_8">完整消息转发</h3>

<p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。<br/>
首先它会发送<strong>-methodSignatureForSelector:</strong>消息获得函数的参数和返回值类型。如果-<strong>methodSignatureForSelector:</strong>返回nil ，Runtime则会发出 <strong>-doesNotRecognizeSelector:</strong> 消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个<strong>NSInvocation</strong> 对象并发送 <strong>-forwardInvocation:</strong>消息给目标对象。</p>

<p><img src="media/15788827057157/15789070035039.jpg" alt="" style="width:765px;"/><br/>
<img src="media/15788827057157/15789070187925.jpg" alt="" style="width:774px;"/><br/>
从打印结果来看，我们实现了完整的转发。通过签名，Runtime生成了一个对象anInvocation，发送给了forwardInvocation，我们在forwardInvocation方法里面让Person对象去执行了foo函数。签名参数v@:怎么解释呢，这里苹果文档Type Encodings有详细的解释。<br/>
以上就是Runtime的三次转发流程。下面我们讲讲Runtime的实际应用。<br/>
<img src="media/15788827057157/15789072653201.jpg" alt="" style="width:987px;"/></p>

<h2 id="toc_9">Runtime 应用</h2>

<ul>
<li>AOP 面向切片编程(埋点方面用的比较多)
<img src="media/15788827057157/15789071021461.jpg" alt="" style="width:702px;"/>
<img src="media/15788827057157/15789071215521.jpg" alt="" style="width:811px;"/></li>
</ul>

<p>下面实现一个UIView的Category添加自定义属性defaultColor。<br/>
<img src="media/15788827057157/15789080004602.jpg" alt="" style="width:839px;"/><br/>
<img src="media/15788827057157/15789080309274.jpg" alt="" style="width:969px;"/></p>

<p><img src="media/15788827057157/15789079081069.jpg" alt="" style="width:961px;"/><br/>
<strong><em>注:weak 的关联内存管理策略是什么?</em></strong><br/>
<a href="https://dayon.gitbooks.io/-ios/content/chapter8.html">https://dayon.gitbooks.io/-ios/content/chapter8.html</a></p>

<h3 id="toc_10">方法添加</h3>

<p><img src="media/15788827057157/15789083218769.jpg" alt="" style="width:943px;"/></p>

<h3 id="toc_11">方法替换</h3>

<p>下面实现一个替换ViewController的viewDidLoad方法的例子。<br/>
<img src="media/15788827057157/15789085581682.jpg" alt="" style="width:1074px;"/><br/>
swizzling应该只在+load中完成。 在 Objective-C 的运行时中，每个类有两个方法都会自动调用。+load 是在一个类被初始装载时调用，+initialize 是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。<br/>
swizzling应该只在dispatch_once 中完成,由于swizzling 改变了全局的状态，所以我们需要确保每个预防措施在运行时都是可用的。原子操作就是这样一个用于确保代码只会被执行一次的预防措施，就算是在不同的线程中也能确保代码只执行一次。Grand Central Dispatch 的 dispatch_once满足了所需要的需求，并且应该被当做使用swizzling 的初始化单例方法的标准。</p>

<h3 id="toc_12">KVO实现</h3>

<p><img src="media/15788827057157/15789086448973.jpg" alt="" style="width:924px;"/><br/>
<img src="media/15788827057157/15789086852696.jpg" alt="" style="width:941px;"/><br/>
<img src="media/15788827057157/15789087796562.jpg" alt="" style="width:950px;"/></p>

<p>注:<br/>
消息转发中&quot;v@:&quot;含义:<br/>
<img src="media/15788827057157/15789066840487.jpg" alt="" style="width:712px;"/></p>

<p>参考：<br/>
<a href="https://juejin.im/post/5ac0a6116fb9a028de44d717">https://juejin.im/post/5ac0a6116fb9a028de44d717</a><br/>
<a href="https://bujige.net/blog/iOS-Runtime-01.html">https://bujige.net/blog/iOS-Runtime-01.html</a><br/>
<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100">https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100</a><br/>
<a href="https://www.jianshu.com/p/ab966e8a82e2">https://www.jianshu.com/p/ab966e8a82e2</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/01/13</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15786431485871.html">
                
                  <h1>KVO && KVC 实现原理</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><img src="media/15786431485871/15786484212119.jpg" alt="" style="width:643px;"/></p>

<h2 id="toc_0">一、什么是 KVO？（Key-VauleObserving）</h2>

<p>KVO 是 OC 对观察者模式的实现，也是 CocoaBinding 的基础，当被观察的对象的某个属性发生改变的时候，观察者对象就会获得通知</p>

<p>面试题：</p>

<blockquote>
<p>addObserver:forKeyPath:options:context:各个参数的作用分别是什么, observer中需要实现哪个方法才能获得KVO回调？</p>
</blockquote>

<pre class="line-numbers"><code class="language-text">**
 1. self.person：要监听的对象
 2. 参数说明：
    * @param addObserver  观察者，负责处理监听事件的对象
    * @param forKeyPath 要监听的属性
    * @param  options 观察的选项（观察新、旧值，也可以都观察）
    * @param context 上下文，用于传递数据，可以利用上下文区分不同的监听
 */
[self.person addObserver:self 
              forKeyPath:@&quot;name&quot; 
                 options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld 
                 context:@&quot;Person Name&quot;];

/**
 *  当监控的某个属性的值改变了就会调用
 *
 *  @param keyPath 监听的属性名
 *  @param object  属性所属的对象
 *  @param change  属性的修改情况（属性原来的值`oldValue`、属性最新的值`newValue`）
 *  @param context 传递的上下文数据，与监听的时候传递的一致，可以利用上下文区分不同的监听
 */
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{
    NSLog(@&quot;%@对象的%@属性改变了：%@&quot;, object, keyPath, change);
}
</code></pre>

<h2 id="toc_1">二、KVO 内部实现原理</h2>

<p>官方文档的说法：</p>

<blockquote>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling.<br/>
KVO使用了名为isa-swizzling的技术</p>

<p>The isa pointer, as the name suggests, points to the object&#39;s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.<br/>
isa指针指向一个对象的类,这个类包含了一个方法派发表</p>

<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.<br/>
被观察对象的isa指针会被修改,指向一个中间类,而非真实的类.isa指针的值并不必须反应实例对象的真实对应的类</p>

<p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.<br/>
因而,应该调用对象的class方法来确定实例对应的类而不是isa指针的值</p>
</blockquote>

<ol>
<li><p>KVO 是基于 runtime 机制实现的。</p>
<blockquote>
<p>KVO 运用了一个 isa-swizzling 技术（类型混合指针机制），将两个对象的 isa 指针互相调换，就是俗称的黑魔法。</p>
</blockquote></li>
<li><p>当某个类的对象 <strong><u><em>第一次被观察</em></u></strong> 的时候，系统就会在运行期<strong><u><em>动态的创建该类的一个派生类</em></u></strong>， 在这个派生类中重写基类中任何被观察属性的 setter 方法，派生类在被重写的 setter 方法内部实现真正的通知机制。</p>
<blockquote>
<p>如果原类为Person，那么生成的派生类名为NSKVONotifying_Person</p>
</blockquote></li>
<li><p>每个类对象中都有一个isa 指针指向当前类，当一个类对象的属性第一次被观察，那么系统就会将 isa 指针指向动态生成的派生类，从而在给被监控的属性赋值的时候执行的是派生类的 setter 方法。</p></li>
<li><p>键值观察通知（KVO）依赖于 NSObject 的两个方法：</p>
<blockquote>
<p>willChangeValueForKey: 和 didChangevlueForKey：<br/>
当一个被观察的属性发生改变之前，willChangeValueForKey： 一定会被调用，这就会记录旧值，当发生改变之后，didChangevlueForKey：会被调用，继而observeValueForKey:ofObject:change:context: 也会被调用。</p>
</blockquote></li>
</ol>

<blockquote>
<p>KVO 的这套实现机制中，苹果还偷偷实现了 class 方法，让我们误以为使用的还是当前的类，从而达到隐藏派生类的目的<br/>
<img src="media/15786431485871/15786460750917.jpg" alt="" style="width:926px;"/></p>
</blockquote>

<h2 id="toc_2">三，如何手动触发 KVO</h2>

<p>手动触发 KVO 必须实现两个方法：<br/>
willChangeValueForKey:和didChangeValueForKey:</p>

<ul>
<li>如何自己动手实现 KVO？<br/>
1，Block 模拟实现 KVO<br/>
大体步骤：<br/>
    1，创建 NSObject 的分类，增加添加观察者的 API，并实现</li>
</ul>

<pre class="line-numbers"><code class="language-text">- (void)PG_addObserver:(NSObject *)observer
                forKey:(NSString *)key
             withBlock:(PGObservingBlock)block {
    //检查对象的类有没有相应的 setter 方法。如果没有抛出异常；
    SEL setterSelector = NSSelectorFromString(setterForGetter(key));
    Method setterMethod = class_getInstanceMethod([self class], setterSelector);
    if (!setterMethod) {
        // throw invalid argument exception
    }
 
    Class clazz = object_getClass(self);
    NSString *clazzName = NSStringFromClass(clazz);
 
    // 检查对象 isa 指向的类是不是一个 KVO 类。如果不是，新建一个继承原来类的子类，并把 isa 指向这个新建的子类；
    if (![clazzName hasPrefix:kPGKVOClassPrefix]) {
        clazz = [self makeKvoClassWithOriginalClassName:clazzName];
        object_setClass(self, clazz);
    }
 
    // 检查对象的 KVO 类重写过没有这个 setter 方法。如果没有，添加重写的 setter 方法；
    //          hasn&#39;t implemented the setter
    if (![self hasSelector:setterSelector]) {
        const char *types = method_getTypeEncoding(setterMethod);
        class_addMethod(clazz, setterSelector, (IMP)kvo_setter, types);
    }
 
    // 添加这个观察者
    PGObservationInfo *info = [[PGObservationInfo alloc] initWithObserver:observer Key:key block:block];
    NSMutableArray *observers = objc_getAssociatedObject(self, (__bridge const void *)(kPGKVOAssociatedObservers));
    if (!observers) {
        observers = [NSMutableArray array];
        objc_setAssociatedObject(self, (__bridge const void *)(kPGKVOAssociatedObservers), observers, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    }
    [observers addObject:info];
}

</code></pre>

<p>再来一步一步细看。<br/>
第一步里，先通过 setterForGetter() 方法获得相应的 setter 的名字（SEL）。也就是把 key 的首字母大写，然后前面加上 set 后面加上 :，这样 key 就变成了 setKey:。然后再用 class_getInstanceMethod 去获得 setKey: 的实现（Method）。如果没有，自然要抛出异常。</p>

<p>第二步，我们先看类名有没有我们定义的前缀。如果没有，我们就去创建新的子类，并通过 object_setClass() 修改 isa 指针。</p>

<pre class="line-numbers"><code class="language-text">- (Class)makeKvoClassWithOriginalClassName:(NSString *)originalClazzName {
    NSString *kvoClazzName = [kPGKVOClassPrefix stringByAppendingString:originalClazzName];
    Class clazz = NSClassFromString(kvoClazzName);
 
    if (clazz) {
        return clazz;
    }
 
    // class doesn&#39;t exist yet, make it
    Class originalClazz = object_getClass(self);
    Class kvoClazz = objc_allocateClassPair(originalClazz, kvoClazzName.UTF8String, 0);
 
    // grab class method&#39;s signature so we can borrow it
    Method clazzMethod = class_getInstanceMethod(originalClazz, @selector(class));
    const char *types = method_getTypeEncoding(clazzMethod);
    class_addMethod(kvoClazz, @selector(class), (IMP)kvo_class, types);
 
    objc_registerClassPair(kvoClazz);
 
    return kvoClazz;
}
</code></pre>

<p>动态创建新的类需要用 objc/runtime.h 中定义的 objc_allocateClassPair() 函数。传一个父类，类名，然后额外的空间（通常为 0），它返回给你一个类。然后就给这个类添加方法，也可以添加变量。这里，我们只重写了 class 方法。哈哈，跟 Apple 一样，这时候我们也企图隐藏这个子类的存在。最后 objc_registerClassPair() 告诉 Runtime 这个类的存在。</p>

<p>第三步，重写 setter 方法。新的 setter 在调用原 setter 方法后，通知每个观察者（调用之前传入的 block ）：</p>

<pre class="line-numbers"><code class="language-text">static void kvo_setter(id self, SEL _cmd, id newValue)  
{
    NSString *setterName = NSStringFromSelector(_cmd);
    NSString *getterName = getterForSetter(setterName);
 
    if (!getterName) {
        // throw invalid argument exception
    }
 
    id oldValue = [self valueForKey:getterName];
 
    struct objc_super superclazz = {
        .receiver = self,
        .super_class = class_getSuperclass(object_getClass(self))
    };
 
    // cast our pointer so the compiler won&#39;t complain
    void (*objc_msgSendSuperCasted)(void *, SEL, id) = (void *)objc_msgSendSuper;
 
    // call super&#39;s setter, which is original class&#39;s setter method
    objc_msgSendSuperCasted(&amp;superclazz, _cmd, newValue);
 
    // look up observers and call the blocks
    NSMutableArray *observers = objc_getAssociatedObject(self, (__bridge const void *)(kPGKVOAssociatedObservers));
    for (PGObservationInfo *each in observers) {
        if ([each.key isEqualToString:getterName]) {
            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                each.block(self, getterName, oldValue, newValue);
            });
        }
    }
}
</code></pre>

<p>细心的同学会发现我们对 objc_msgSendSuper 进行类型转换。在 Xcode 6 里，新的 LLVM 会对 objc_msgSendSuper 以及 objc_msgSend 做严格的类型检查，如果不做类型转换。Xcode 会抱怨有 too many arguments 的错误。（在 WWDC 2014 的视频 What new in LLVM 中有提到过这个问题。）</p>

<p>最后一步，把这个观察的相关信息存在 associatedObject 里。观察的相关信息（观察者，被观察的 key, 和传入的 block ）封装在 PGObservationInfo 类里。</p>

<pre class="line-numbers"><code class="language-text">@interface PGObservationInfo : NSObject
 
@property (nonatomic, weak) NSObject *observer;
@property (nonatomic, copy) NSString *key;
@property (nonatomic, copy) PGObservingBlock block;
 
@end
</code></pre>

<p>就此，一个基本的 KVO 就可以 work 了。当然，这只是一个一天多做出来的小东西，会有 bug，也有很多可以优化完善的地方。但作为 demo 演示如何利用 Runtime 动态创建类、如何实现 KVO，足已。</p>

<ul>
<li>KVO 使用注意点<br/>
苹果提供的KVO自身存在很多问题，首要问题在于，KVO如果使用不当很容易崩溃。例如重复add和remove导致的Crash，Observer被释放导致的崩溃，keyPath传错导致的崩溃等。</li>
</ul>

<p>在调用KVO时需要传入一个keyPath，由于keyPath是字符串的形式，所以其对应的属性发生改变后，字符串没有改变容易导致Crash。我们可以利用系统的反射机制将keyPath反射出来，这样编译器可以在@selector()中进行合法性检查。<br/>
KVO是一种事件绑定机制的实现，在keyPath对应的值发生改变后会回调对应的方法。这种数据绑定机制，在对象关系很复杂的情况下，很容易导致不好排查的bug。例如keyPath对应的属性被调用的关系很复杂，就不太建议对这个属性进行KVO，可以想一下RAC的信号脑补一下。</p>

<h2 id="toc_3">KVC 是什么</h2>

<blockquote>
<p>KVC（Key-value coding）键值编码，就是指iOS的开发中，可以允许开发者通过Key名直接访问对象的属性，或者给对象的属性赋值。而不需要调用明确的存取方法。这样就可以在运行时动态地访问和修改对象的属性。而不是在编译时确定，这也是iOS开发中的黑魔法之一。很多高级的iOS开发技巧都是基于KVC实现的。</p>
</blockquote>

<p>KVC最为重要的四个方法：</p>

<pre class="line-numbers"><code class="language-text">- (nullable id)valueForKey:(NSString *)key;                          //直接通过Key来取值

- (void)setValue:(nullable id)value forKey:(NSString *)key;          //通过Key来设值

- (nullable id)valueForKeyPath:(NSString *)keyPath;                  //通过KeyPath来取值

- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;  //通过KeyPath来设值
</code></pre>

<h2 id="toc_4">isa 指针是什么类型的？</h2>

<p>runtime 中，class 和 object 的定义：</p>

<pre class="line-numbers"><code class="language-text">typedef struct objc_class *Class;
typedef struct objc_object {
    Class isa;
} *id;
</code></pre>

<p>Class 是一个 objc_class 结构类型的指针；<br/>
而 id（任意对象） 是一个 objc_object 结构类型的指针，其第一个成员是一个 objc_class 结构类型的指针。注意这里有一关键的引申解读：内存布局以一个 objc_class 指针为开始的所有东东都可以当做一个 object 来对待！ <br/>
那 objc_class 又是怎样一个结构体呢？</p>

<pre class="line-numbers"><code class="language-text">struct objc_class {
    struct objc_class* isa;
    struct objc_class* super_class;
    const char* name;
    long version;
    long info;
    long instance_size;
    struct objc_ivar_list* ivars;
    struct objc_method_list** methodLists;
    struct objc_cache* cache;
    struct objc_protocol_list* protocols;
};
</code></pre>

<p>objc_class 结构体的各成员介绍如下：</p>

<p>isa：是一个 objc_class 类型的指针，看到这里，想起我前面的引申解读了没？内存布局以一个 objc_class 指针为开始的所有东东都可以当做一个 object 来对待！ 这就是说 objc_class 或者说类其实也可以当做一个 objc_object 对象来对待！对象是对象，类也是对象，是不是有点混淆？别急，ObjC发明（or 重用）了一个术语来区分这两种不同的对象：类对象（class object）与实例对象（instance object）。OK，名称混淆的问题解决，下面我将使用这两个术语来区分不同的对象，而使用“对象”这一术语来泛指所有的对象。ObjC还对类对象与实例对象中的 isa 所指向的类结构作了不同的命名：类对象中的 isa 指向类结构被称作 metaclass，metaclass 存储类的static类成员变量与static类成员方法（+开头的方法）；实例对象中的 isa 指向类结构称作 class（普通的），class 结构存储类的普通成员变量与普通成员方法（-开头的方法）。</p>

<p>super_class：一看就明白，指向该类的父类呗！如果该类已经是最顶层的根类（如 NSObject 或 NSProxy），那么 super_class 就为 NULL。</p>

<p>好，先中断一下其他类结构成员的介绍，让我们厘清一下在继承层次中，子类，父类，根类（这些都是普通 class）以及其对应的 metaclass 的 isa 与 super_class 之间关系:</p>

<p>规则一：类的实例对象的 isa 指向该类；该类的 isa 指向该类的 metaclass；<br/>
规则二：类的 super_class 指向其父类，如果该类为根类则值为 NULL；<br/>
规则三：metaclass 的 isa 指向根 metaclass，如果该 metaclass 是根 metaclass 则指向自身；<br/>
规则四：metaclass 的 super_class 指向父 metaclass，如果该 metaclass 是根 metaclass 则指向该 metaclass 对应的类；</p>

<p>好吧，文字总是那么乏力，有图有真相！<br/>
<img src="media/15786431485871/15786497073771.jpg" alt="" style="width:601px;"/></p>

<p>那么 class 与 metaclass 有什么区别呢？</p>

<p>class 是 instance object 的类类型。当我们向实例对象发送消息（实例方法）时，我们在该实例对象的 class 结构的 methodlists 中去查找响应的函数，如果没找到匹配的响应函数则在该 class 的父类中的 methodlists 去查找（查找链为上图的中间那一排）。如下面的代码中，向str 实例对象发送 lowercaseString 消息，会在 NSString 类结构的 methodlists 中去查找 lowercaseString 的响应函数。</p>

<p>metaclass 是 class object 的类类型。当我们向类对象发送消息（类方法）时，我们在该类对象的 metaclass 结构的 methodlists 中去查找响应的函数，如果没有找到匹配的响应函数则在该 metaclass 的父类中的 methodlists 去查找（查找链为上图的最右边那一排）。如下面的代码中，向 NSString 类对象发送 stringWithString 消息，会在 NSString 的 metaclass 类结构的 methodlists 中去查找 stringWithString 的响应函数。</p>

<hr/>

<p>参考：<br/>
<a href="https://www.jianshu.com/p/829864680648">https://www.jianshu.com/p/829864680648</a><br/>
<a href="https://xiaozhuanlan.com/topic/0892715634">https://xiaozhuanlan.com/topic/0892715634</a><br/>
<a href="https://tech.glowing.com/cn/implement-kvo/">https://tech.glowing.com/cn/implement-kvo/</a><br/>
<a href="https://juejin.im/post/5aeff463f265da0b851cc6ac">https://juejin.im/post/5aeff463f265da0b851cc6ac</a><br/>
<a href="https://blog.csdn.net/Zsk_Zane/article/details/48194975">https://blog.csdn.net/Zsk_Zane/article/details/48194975</a><br/>
<a href="https://juejin.im/post/5aef18b76fb9a07aa34a28e6">https://juejin.im/post/5aef18b76fb9a07aa34a28e6</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/01/10</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15784529401988.html">
                
                  <h1>Label 多行换行最后一行现在更过按钮</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><img src="media/15784529401988/15784530763900.jpg" alt="" style="width:574px;"/><br/>
这种多行之后（最多显示几行），最后一行还显示不下的时候，要求有更多按钮（或者全文）这种需求很常见。实现方法也比较简单，结合 NSAttributeSring 和 YYLabel 就能很简单的实现。如果最后的“更多”或者“全文”按钮要求自提颜色或者大小不一样，单独处理这个样式即可</p>

<pre class="line-numbers"><code class="language-text">- (void)addSeeMoreButton {
    
    NSMutableAttributedString *text = [[NSMutableAttributedString alloc] initWithString:@&quot;   ... 全文&quot;];
    //添加文字颜色
    [text addAttribute:NSForegroundColorAttributeName value:kColor_black1 range:NSMakeRange(text.length-2, 2)];
    [text addAttribute:NSForegroundColorAttributeName value:kColor_black2 range:NSMakeRange(0, text.length-2)];
    
    
    YYLabel *seeMore = [YYLabel new];
    seeMore.attributedText = text;
    [seeMore sizeToFit];
    NSMutableAttributedString *truncationToken = [NSMutableAttributedString attachmentStringWithContent:seeMore contentMode:UIViewContentModeCenter attachmentSize:seeMore.frame.size alignToFont:[UIFont systemFontOfSize:14] alignment:YYTextVerticalAlignmentCenter];
    self.passageContentLabel.truncationToken = truncationToken;
}

</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/01/08</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15780315733102.html">
                
                  <h1>探寻 OC 对象的本质</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>面试题：一个 NSObject 对象占用多少内存？</p>
</blockquote>

<p>我们平时编写的代码都是 Objective-C 的代码，但是底层实现其实都是 C/C++的代码</p>

<pre class="line-numbers"><code class="language-text">#import &lt;Foundation/Foundation.h&gt;
#import &lt;malloc/malloc.h&gt;
#import &lt;objc/runtime.h&gt;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSObject *obj = [[NSObject alloc] init];
        // 创建一个实例对象，实际上分配多少内存 - 16
        NSLog(@&quot;%zd&quot;, malloc_size((__bridge const void *)obj));

        // 创建一个实例对象，至少需要多少内存 - 8
        NSLog(@&quot;%zd&quot;, class_getInstanceSize([NSObject class]));
    }
    return 0;
}
</code></pre>

<ul>
<li>系统分配了 16 个字节给 NSObject 对象（通过 malloc——size 函数获得）</li>
<li><p>OC 源码显示分配给对象的内存为 16 个字节的整数倍，至少是 16 个字节</p>
<p><img src="media/15780315733102/15780350303674.jpg" alt="" style="width:660px;"/></p></li>
</ul>

<blockquote>
<p>OC的对象、类主要是基于C\C++的什么数据结构实现的呢？<br/>
结构体<br/>
OC 的对象是基于 C 的结构体实现的<br/>
这个结构体只有一个成员：isa 指针，而指针在 64 位架构中占 8 个字节。<br/>
那么这个结构体占多大的内存空间呢，我们发现这个结构体只有一个成员，isa指针，而指针在64位架构中占8个字节。也就是说一个NSObjec对象所占用的内存是8个字节。到这里我们已经可以基本解答第一个问题。但是我们发现NSObject对象中还有很多方法，那这些方法不占用内存空间吗？其实类的方法等也占用内存空间，但是这些方法所占用的存储空间并不在NSObject对象中。</p>
</blockquote>

<h2 id="toc_0">实例对象 类（对象） 元类</h2>

<p><img src="media/15780315733102/15780363563241.jpg" alt="" style="width:552px;"/></p>

<blockquote>
<ol>
<li>instance的isa指向class</li>
<li>class的isa指向meta-class</li>
<li>meta-class的isa指向基类的meta-class，基类的isa指向自己</li>
<li>class的superclass指向父类的class，如果没有父类，superclass指针为nil</li>
<li>meta-class的superclass指向父类的meta-class，基类的meta-class的superclass指向基类的class</li>
<li>instance调用对象方法的轨迹，isa找到class，方法不存在，就通过superclass找父类</li>
<li>class调用类方法的轨迹，isa找meta-class，方法不存在，就通过superclass找父类</li>
</ol>
</blockquote>

<h2 id="toc_1">为什么会存在元类？</h2>

<p>元类是一个类对象的类<br/>
简而言之：<br/>
当你向一个对象发送一条消息的时候，运行时会在对象的类的方法列表中查找这条消息是否存在。<br/>
当你向一个类发送一条消息的时候，运行时会在类的元类的方法列表中查找这条消息是否存在。</p>

<p>元类的存在是必需的，因为他存储了一个类的所有类方法。每个类的元类都是独一无二的，因为每个类都有一系列独特的类方法。<br/>
什么是元类的类</p>

<p>元类，和类一样，也是一个对象。这表示你能够对元类调用方法。自然的，这表示他必须也有一个类指针。</p>

<p>所有元类使用基类的元类（即继承链顶端的类的元类）作为他们的类，而所有类的基类都是 NSObject（大多数类是这样的），所以大多数元类使用 NSObject 的元类作为他的类。</p>

<p>根据规则所有元类使用基类的元类作为他们的类，那么基类的元类就是他自己的类（他们的isa指针指向了自己）。这表明NSObject的元类的指针指向的是他自己（他是一个他自己的实例）。</p>

<h2 id="toc_2">继承类和元类</h2>

<p>同样的，类使用 super_class 指针指向他们的 superclass，元类也有 super_class 指针来指向 superclass。<br/>
这里又有一个奇怪的地方，基类的元类设置的 superclass 是基类自己。<br/>
这种继承结构导致的结果是所有结构中的实例、类以及元类都继承自结构中的基类。</p>

<p>所有实例、类和元类都在 NSObject 的层级下，这表明所有 NSObject 的实例方法都能够被使用，同样的，对类以及元类来说，所有 NSObject 的类方法也是有效的。</p>

<h2 id="toc_3">元类总结：</h2>

<p>元类是一个类对象的类。每一个类有他自己独一无二的元类（因为每个类能够有自己独一无二的方法列表）。这就意味着类对象的类并不是和他们一样的类。</p>

<p>元类能确保类对象有所有底层类的实例和类方法，中间加上所有自己的类方法。所有类继承自NSObject，这意味着NSObject所有的实例和协议方法为所有类（和元类）对象都定义了。</p>

<p>所有元类使用基类的元类（NSObject 元类）来作为他们的类，包括只在运行时自定义的类的元类。</p>

<p>参考：<br/>
<a href="https://juejin.im/post/5ac81c75518825556534c0af">https://juejin.im/post/5ac81c75518825556534c0af</a><br/>
<a href="https://www.jianshu.com/p/79b06fabb459">https://www.jianshu.com/p/79b06fabb459</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/01/03</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="shu-xing-de-shi-zhi-shu-xing-d.html">
                
                  <h1>属性的实质</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>属性的实质是什么？<br/>
包括哪几个部分？<br/>
属性默认的关键字都有哪些？<br/>
@dynamic关键字和@synthesize关键字是用来做什么的</p>
</blockquote>

<p>实质包含部分:</p>

<p>@property = ivar + getter + setter;</p>

<p>实例变量+get方法+ set方法，也就是说使用@property系统会自动生成setter和getter方法;</p>

<p>默认常用关键字:</p>

<p>property中我们经常使用的关键字有strong，weak，assign，copy，nonatomic，atomic....等</p>

<p>@dynamic这个关键词，通常是用不到的。<br/>
它与@synthesize的区别在于：<br/>
使用@synthesize编译器会确实的产生getter和setter方法，而@dynamic仅仅是告诉编译器这两个方法在运行期会有的，无需产生警告。</p>

<p>假设有这么个场景，B类，C类分别继承A类，A类实现某个协议（@protocol），协议中某个属性( somePropety )我不想在A中实现，而在B类，C类中分别实现。如果A中不写任何代码，编译器就会给出警告：“use @synthesize, @dynamic or provide a method implementation&quot;这时你给用@dynamic somePropety; <br/>
编译器就不会警告，同时也不会产生任何默认代码。</p>

<p>@dynamic 就是要来告诉编译器，代码中用@dynamic修饰的属性，其getter和setter方法会在程序运行的时候或者用其他方式动态绑定，以便让编译器通过编译。<br/>
其主要的作用就是用在NSManageObject对象的属性声明上，由于此类对象的属性一般是从Core Data的属性中生成的，Core Data框架会在程序运行的时候为此类属性生成getter和Setter方法。</p>

<p>参考:</p>

<p><a href="">https://www.jianshu.com/p/00dbeec23291</a></p>

<hr/>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/01/03</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15780200209710.html">
                
                  <h1>iOS 响应者链及事件传递</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">UIResponder</h2>

<p>在 iOS中，所有响应事件处理事件的对象都直接或间接的继承UIResponder。<br/>
在 iOS 视图结构中，呈现出来的是一个 N 叉树的树形结构，每个视图都只有一个父视图，可以有多个子视图。<br/>
<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9lpldkdtyj30he0go46i.jpg" alt=""/></p>

<h2 id="toc_1">寻找第一响应者</h2>

<p>当用户点击某个视图或者按钮的时候，会首先响应 applocation 中的 UIWindow 一层一层的向下查找，直到找到点击的 view，这阶段用到的两个方法：</p>

<pre class="line-numbers"><code class="language-text">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;   // recursively calls -pointInside:withEvent:. point is in the receiver&#39;s coordinate system
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;   // default returns YES if point is in bounds
</code></pre>

<p>例如有这样一个图层结构：<br/>
<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9lpsaqbekj30e80jamy9.jpg" alt=""/></p>

<p>在上图中用户点击视图中的ViewD时，UIWindow首先接收到响应，此响应包括用户点击的区域和一个封装好的UIEvent对象，然后UIWindow通过这些信息利用以下方法查找：</p>

<ol>
<li><p>UIWindow会通过调用pointInside:withEvent:方法返回的YES得知用户点击的范围在ViewA中；</p></li>
<li><p>ViewA调用hitTest:withEvent:方法，在方法中遍历所有的subView(ViewB、ViewC)调用hitTest:withEvent:方法；</p></li>
<li><p>在遍历中发现使用ViewC调用pointInside:withEvent:方法时返回YES，得知用户点击在ViewC范围之内；</p></li>
<li><p>ViewC调用hitTest:withEvent:方法，在方法中遍历所有的subView(ViewD、ViewE)调用hitTest:withEvent:方法;</p></li>
<li><p>在遍历中发现使用ViewD调用pointInside:withEvent:方法时返回YES，得知用户点击在ViewD范围之内;</p></li>
<li><p>在ViewD调用hitTest:withEvent:方法之前发现View的subViews的count为0，故确定用户点击在ViewD之上。</p></li>
</ol>

<p>UIWindow会用遍历subviews，使用每一个subview调用hitTest:withEvent:方法，如果用户点击在某一个subview上，pointInside:withEvent:方法返回YES，再用这个subview调用hitTest:withEvent:方法，依次类推，直到当前view没有子view或点击的位置没有在其任何子view之上，便确定用户点击在某view上</p>

<pre class="line-numbers"><code class="language-text">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{
    for (UIView *view in self.subviews) {
        if([view pointInside:point withEvent:event]){
            UIView *hitTestView = [view hitTest:point withEvent:event];
            if(nil == hitTestView){
                return view;
            }
        }
    }
    return nil;
}
</code></pre>

<blockquote>
<p>1.Alpha=0、子视图超出父视图的情况、userInteractionEnabled=NO、hidden=YES视图会被忽略，不会调用hitTest<br/>
2.父视图被忽略后其所有子视图也会被忽略<br/>
3.出现视图无法响应的情况，可以考虑上诉情况来排查问题</p>
</blockquote>

<h2 id="toc_2">事件传递</h2>

<p>事件传递的顺序其实就是寻找第一响应者的逆序，当找到了第一响应（View，button）之后，响应者就要对事件作出响应，这里就是使用了 UIResponder 的 nextResponder 方法。</p>

<h3 id="toc_3">nextResponder 的规则</h3>

<p>因为UIView和UIViewController都是继承于UIResponder，所以在调用nextResponder时有几条规则如下：</p>

<ol>
<li><p>当一个view调用其nextResponder会返回其superView;</p></li>
<li><p>如果当前的view为UIViewController的view被添加到其他view上，那么调用nextResponder会返回当前的UIViewController，而这个UIViewController的nextResponder为view的superView；</p></li>
<li><p>如果当前的UIViewController的view没有添加到任何其他view上，当前的UIViewController的nextResponder为nil，不管它是keyWinodw或UINavigationController的rootViewController，都是如此；</p></li>
<li><p>如果当前application的keyWindow的rootViewController为UINavigationController(或UITabViewController)，那么通过调用UINavigationController(或UITabViewController)的nextResponder得到keyWinodw；</p></li>
<li><p>keyWinodw的nextResponder为UIApplication，UIApplication的nextResponder为AppDelegate，AppDelegate的nextResponder为nil。</p></li>
</ol>

<p>通过知道了上述规则，便可以通过用户点击的ViewD，查看ViewD是否响应了点击事件，如果没有找它的nextResponder，如果没有再继续找，直到找到AppDelegate再没有响应，则此点击事件被系统丢弃，大致流程如下：<br/>
<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9lu7zsmnqj30fa0f8adu.jpg" alt=""/><br/>
事件响应链的大致流程就是如此了，大概就是一个先向下找，再向上找的过程！</p>

<h2 id="toc_4">无法响应的情况</h2>

<p>参考：<br/>
<a href="">https://www.cnblogs.com/easy-coding/p/3604856.html</a></p>

<p><a href="">https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/using_responders_and_the_responder_chain_to_handle_events?language=objc</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/01/03</span>
                    
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="img/icon.jpg" /></div>
            
                <h1>小马同学的碎碎念</h1>
                <div class="site-des">小马同学的碎碎念</div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/macongLeo/macongLeo.github.io.git" title="GitHub">GitHub</a>

  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15794268006874.html">iOS 技术文档计划</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15791552193020.html">RunLoop 详解</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15788827057157.html">Runtime</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15786431485871.html">KVO && KVC 实现原理</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15784529401988.html">Label 多行换行最后一行现在更过按钮</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
